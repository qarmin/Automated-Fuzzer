[general]
loop_number = 5000 # How much creating/removing/checking steps will be executed
broken_files_for_each_file = 100# Number of broken files that will be created for each 1 valid file
minimize_output = true # Tries to remove some lines from output file, remember, that not always minimized file will produce same error - usually minimize output 2-100 times
temp_possible_broken_files_dir = "/opt/POSSIBLY_BROKEN_FILES_DIR" # Place where possibly broken files are saved
minimization_attempts = 3000 # Attemps to minimize code, counter reset when found minimized test case
minimization_attempts_with_signal_timeout = 10 # Usually signal is sended by OOM killer or timeout which is slow to reproduce and minimize, so use it less amount than normal
debug_print_results = false # Debug prints output of commands
debug_executed_commands = false # Debug prints executed commands
debug_print_broken_files_creator = false # Debug prints results of command that created broken files
remove_non_crashing_items_from_broken_files = false # Special mode to remove non crashing files from broken files - useful if some of files were fixed in new version of app
find_minimal_rules = false # If true, will try to find minimal rules that will produce error, files will be taken from BROKEN_FILES_DIR
temp_folder = "TMP_FOLDER_TO_REPLACE" # Temp file used to store random data
timeout = 100 # timeout time, if equal zero, then timeout is disabled - CAUTION - it is also used with grouping, which can a lot of easily exceed this time
allowed_error_statuses = "0,1,2,101" # Treat file as broken if exit code is different than 0 or 1 (this is sometimes )
ignore_timeout_errors = false
error_when_found_signal = true # Errors, when app was killed by OS or user
max_collected_files = 1000000000 # Max number of files that will be collected from valid_input_files_dir
check_if_file_is_parsable = false #true # If true, will check if file is parsable, if not, then will be removed
grouping = 100 # How many files will be grouped in one command - using bigger number than 1 will add additional step, with checking multiple files in one command

current_mode = "custom"

[custom]
name = "name"
valid_input_files_dir = "/opt/VALID_FILES_DIR"
broken_files_dir = "/opt/BROKEN_FILES_DIR"
tool_type = "" # This not works in general mode, needs to create new toml file with different command
# This not works in general mode, needs to create new toml file with different command

# Available
# none(grouping number is ignored and files are only checked one by one)
# by_files(files are checked at once e.g. biome file1.js file2.js)
# by_group(files are put in folder and checked at once e.g. biome folder1)
group_mode = "none"
# Items element is replaced by files or folder, | is separator to be able to use space in command
# This command will be executed as 'biome item1.js item2.js --file --exc"tak nie"'
command = "biome|FILE_PATHS_TO_PROVIDE|--file|--exc\"tak nie\""
# search_item_* is list of items, that will indicate that error was found
# numbers aded to this string can be random, but they need to be unique to be valid in toml file
search_item_1 = "RUST_BACKTRACE"
search_item_2 = "panicked at"
search_item_100 = "AddressSanitizer"
search_item_101 = "LeakSanitizer"
search_item_102 = "ThreadSanitizer"
# ignored_item_* is list of items to ignore e.g. already reported earlier errors
ignored_item_1 = "src/hb/buffer.rs"
# Type of files/broken files to be created, using e.g. rust will use text and add in random places
# random rust keywords, to crash programs even more
# Available: text, binary, js, go, rust, lua, python
file_type = "text" # Available: text, binary, js, go, rust, lua, python